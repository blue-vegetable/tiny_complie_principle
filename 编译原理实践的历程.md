#### 编译原理实践的历程

昨天是5月20日,看了下编译原理实践的前两章,没啥进展

----------

现在是5月21日,打算看一下源代码

1. 先是gloabals.h

   上次看的ifndef编译开关又忘记了, 百度一手

> **#define x** //定义一个宏
>
> ...
>
> \#endif
>
> //C语言在对程序进行编译时，会先根据[预处理命令](https://baike.baidu.com/item/预处理命令)进行“预处理”。C语言[编译系统](https://baike.baidu.com/item/编译系统)包括预处理，编译和链接等部分。
>
> **#ifndef x** //先测试x是否被宏定义过
>
> **#define x**
>
> 程序段1 //如果x没有被宏定义过，定义x，并[编译程序](https://baike.baidu.com/item/编译程序)段 1
>
> **#else**
>
> 程序段2 //如果x已经定义过了则编译程序段2的语句，“忽视”程序段 1
>
> **#end****if**//终止if

​	初看是定义了保留字的个数 , 定义了一个enum(枚举体) , 把Token类型枚举了一	遍,包括EOF, ERROR,保留字,标识符,运算符.

​	引了一些外部变量,源文件,输出文件(?) ,TM机可执行的文件, 此时的代码行

​	又用枚举体定义结点类型,分为语句(stmt)型和表达式型(exp), 定义语句类别,if语	句,repeat语句,赋值语句之类的. 定义表达式类型,运算符还是常量还是ID,定义表达	式结果的类型,是int 还是void还是boolen.

​	宏定义一个树的最大节点数为3 . 然后定义了语法树 

​	最后extern了一些开关.

2. 根据顺序的话首先是词法分析,先去康康scan.c啥的 ,发现它include了util.h,那就去看看util.c 里面有什么

   定义了一个printToken , 顾名思义吧 ,就是把Token存进文件里 (listing) , 也带点token识别功能,会区别 Id 和 NUM.

   后面的东西涉及语法树了 , 写了两个初始化结点的函数, 一个生成语句结点, 一个生成表达式结点,没啥好说的

   定义了一个比较安全的防止缓冲区溢出的copystring ,笑死其实感觉没啥区别,不过肯定比较安全.

   一个内部变量indentno 用于记录空格数 ,也宏定义了两个操作一个INDENT 用于indentno+2, UNINDENT 用于indetno-2

   再就是一个打印空格和递归打印语法树的函数.

3. 好了现在再又来看scan.c

   开场一个枚举类型定义DFA的各种状态 , 定义了一个token的数组,定义了一个缓冲区用于存当前行, 也限制了当前行最长为256个字符.定义一些待会要用到的扫描句子的变量, EOF_flag用于纠正到达EOF后的操作.

   getNextchar函数获取缓冲区中的下一个字符 ,而且还能换行, 自动换到下一行

   ungetNextchar函数退回刚刚get到的字符 , 比如遇到EOF的时候

   定义了一个结构体, 映射每个保留字.

   ReservedLookup函数用于匹配当前字符串是哪个保留字.

   getToken实现了DFA

   输入是全局变量currentToken , 输出暂存在全局变量tokenString数组 ,然后借助printToken打印进listing ,最后return出去, 猜测应该是要统一保存的

4. 然后是第三章 , 文法分析

   先把这个文法打在这里

   ![image-20210521201737065](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20210521201737065.png)

   然后一些对语法树的解释,也放在这里方便待会理解代码

   ![image-20210521202101858](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20210521202101858.png)

![image-20210521202109167](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20210521202109167.png)

![image-20210521202116750](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20210521202116750.png)

write 语句也有一个孩子，它表示要写出值的表达式

![image-20210521202129570](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20210521202129570.png)

![image-20210521202138052](C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20210521202138052.png)

其他结点都是叶子结点(read语句, 标识符表达式, 常量表达式)

5. 然后是第四章, 自顶向下的分析

   内容太多,先挂着, 有时间再看,直奔主题 , 看代码,语法分析parse.c ,代码不多, 200左右 ,开始

   前期就是一阵函数声明, 一个变量存储当前的token类型, 然后声明了很多结点 , 每个函数其实就是上面的文法中的产生式的属性的名字.然后按照文法的逻辑构造相应的语法树.看stmtment产生式和stmtment函数就能略知一二.

   定义了个syntaxError函数 , 顾名思义 ,报错用的

   定义了个match函数, 递归下降子程序法的一样

   

--------

现在是5月22日, 我又来搞编译原理了

1. 随手打开的SYMTAB.C, 顾名思义符号表

   hash函数没看懂在干啥 ,

   后来看到st_insert发现它在把一个字符串处理成一个数字, 不过好像没有解决哈希冲突什么的, 再看看

   LineListRec 结构体, 在BucketListRec中用到, 用于记录每一个符号在哪些行出现过。

   BucketListRec就是记录符号的数据结构， 整个哈希表的定义就是static BucketList hashTable[SIZE];

   发现st_insert就是一个把得到的符号放进符号表中函数, 对之前没有出现过的符号放进表中, 之前出现过的就在原节点的lineno后面再接一个结点表示该符号号在这新的一行出现过.哈希冲突也是在这里解决的，在此处并不是数组的一个元素存一个符号，而是存了存储所有哈希值相等的符号的链表的头结点，四舍五入就是解决了哈希冲突。

   st_lookup查找符号的内存地址，先算出哈希值，然后比对哈希表中该位置下的链表中名字相同的 ，最后得到内存地址。

   printSymTab没啥好说的就是打印出符号表

   好这个也看完了 ，下一个C
   
2. 好了现在到语义分析 ， ANALYZE.C来也

   yysy这个preproc和这个postproc是真的不知道什么东西，看不太懂是在干啥，老老实实去看第六章语义分析了

   哦原来是两个函数指针，这里的traverse就是对树的遍历 ，然后在前序遍历的时候执行preproc函数 ， 在后序遍历的时候执行postproc函数，其他的函数也没啥好说的了 ，都是对树的和符号表的操作，就是试图得到一个带有属性的语法树

3. 感觉后面的东西学的不是很扎实，看的就很疲软 ， code.c和cgen.c 就看不太懂
   
   main.c还是知道， 主要在搞输出 tm.c就是在搞tm机了， 还挺复杂的， 暂且就先不看了， 想试图运行一下这个程序

--------

今天是5月25日,转眼三天没有搞编译原理了, 简直了

想要试图运行一下这个程序, 感受一下它到底在干啥。

不知道为什么在linux还是wsl还是windows下， 它都不能正常make

都会报这个错误

```bash
No targets specified and no makefile found.  Stop
```

然后在linux里花式报错误, 经询问同学决定重新在windows下搞

-----

近几天在复习专业英语了, 现在有较多时间放下来搞这个了

哦对了今天是5月27日了

首先是想要把代码跑起来.

大致的跑代码流程是这样的:

>把TINY编译器的源代码文件编译成可执行文件TINY.exe。然后用TINY.exe编译一个用TINY语言写的源程序（放在sample.tny文件中）。TINY.exe会生成sample.tm文件，这个就是编译后的目标文件(可执行文件）。再用TM.exe这个虚拟机来运行sample.tm文件，得到sample.tm文件的运行结果

